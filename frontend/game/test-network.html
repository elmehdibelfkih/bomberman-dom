<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bomberman - Network Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            display: flex;
            height: 100vh;
        }

        #sidebar {
            width: 300px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
        }

        #game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #canvas {
            border: 3px solid #0f0;
            background: #000;
            image-rendering: pixelated;
        }

        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px;
            margin: 5px 0;
            width: 100%;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background: #0d0;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        input {
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 8px;
            width: 100%;
            margin: 5px 0;
        }

        .section {
            margin: 20px 0;
            padding: 10px;
            background: #333;
            border-radius: 5px;
        }

        .status {
            padding: 10px;
            background: #000;
            border: 2px solid #0f0;
            margin-bottom: 10px;
        }

        .status.disconnected {
            border-color: #f00;
        }

        #log {
            background: #000;
            border: 2px solid #0f0;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            font-size: 11px;
        }

        .log-entry {
            margin: 2px 0;
        }

        .log-error {
            color: #f00;
        }

        .log-success {
            color: #0f0;
        }

        .log-info {
            color: #0af;
        }

        #info {
            margin-top: 10px;
            font-size: 12px;
        }

        .player-info {
            background: #222;
            padding: 5px;
            margin: 5px 0;
            border-left: 3px solid #0f0;
        }
    </style>
</head>

<body>
    <div id="sidebar">
        <h2>üéÆ Bomberman</h2>
        <div class="status disconnected" id="status">Disconnected</div>

        <div class="section">
            <input type="text" id="nickname" placeholder="Nickname" value="Player1">
            <button id="join-btn">Join Game</button>
        </div>

        <div class="section">
            <h3>Controls</h3>
            <button id="up-btn">‚Üë UP (W)</button>
            <button id="left-btn">‚Üê LEFT (A)</button>
            <button id="down-btn">‚Üì DOWN (S)</button>
            <button id="right-btn">‚Üí RIGHT (D)</button>
            <button id="bomb-btn">üí£ BOMB (Space)</button>
        </div>

        <div class="section">
            <h3>Players</h3>
            <div id="players-list"></div>
        </div>

        <div class="section">
            <button id="state-btn">Request State</button>
            <button id="clear-btn">Clear Log</button>
        </div>

        <div id="log"></div>
    </div>

    <div id="game-container">
        <canvas id="canvas" width="960" height="704"></canvas>
        <div id="info"></div>
    </div>

    <script type="module">
        const GRID_WIDTH = 15;
        const GRID_HEIGHT = 11;
        const CELL_SIZE = 64;
        const WS_URL = 'ws://localhost:9090';

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const log = document.getElementById('log');
        const status = document.getElementById('status');
        const info = document.getElementById('info');
        const playersList = document.getElementById('players-list');

        let ws = null;
        let gameState = { players: [], bombs: [], explosions: [], powerups: [], map: [], mapData: null };
        let myPlayerId = null;
        let connected = false;

        // Colors
        const COLORS = {
            floor: '#2a2a2a',
            wall: '#555',
            block: '#8b4513',
            player: ['#00f', '#f00', '#0f0', '#ff0'],
            bomb: '#000',
            explosion: '#ff6600',
            powerup: '#f0f'
        };

        function addLog(msg, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function updateStatus(text, isConnected) {
            status.textContent = text;
            status.className = isConnected ? 'status' : 'status disconnected';
            connected = isConnected;
        }

        function updatePlayersList() {
            playersList.innerHTML = gameState.players.map(p =>
                `<div class="player-info" style="border-color: ${COLORS.player[p.colorIndex || 0]}">
                    ${p.nickname || p.playerId} ${p.playerId === myPlayerId ? '(YOU)' : ''}<br>
                    ‚ù§Ô∏è ${p.lives || 0} | üí£ ${p.bombCount || 1} | üî• ${p.bombRange || 1}
                </div>`
            ).join('');
        }

        function updateInfo() {
            const me = gameState.players.find(p => p.playerId === myPlayerId);
            if (me) {
                info.innerHTML = `
                    <strong>Your Stats:</strong> 
                    Lives: ${me.lives || 0} | 
                    Bombs: ${me.bombCount || 1} | 
                    Flame: ${me.bombRange || 1} | 
                    Speed: ${me.speed || 1} | 
                    Position: (${me.gridX}, ${me.gridY})
                `;
            }
        }

        function drawGrid() {
            ctx.fillStyle = COLORS.floor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw map
            const grid = gameState.mapData?.initial_grid || gameState.map;
            if (grid && grid.length > 0) {
                for (let y = 0; y < grid.length; y++) {
                    for (let x = 0; x < grid[y].length; x++) {
                        const cell = grid[y][x];
                        if (cell === 1) { // Wall
                            ctx.fillStyle = COLORS.wall;
                            ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        } else if (cell === 2) { // Block
                            ctx.fillStyle = COLORS.block;
                            ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                    }
                }
            }

            // Draw grid lines
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for (let x = 0; x <= GRID_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL_SIZE, 0);
                ctx.lineTo(x * CELL_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= GRID_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL_SIZE);
                ctx.lineTo(canvas.width, y * CELL_SIZE);
                ctx.stroke();
            }
        }

        function drawExplosions() {
            gameState.explosions?.forEach(exp => {
                ctx.fillStyle = COLORS.explosion;
                ctx.globalAlpha = 0.7;
                exp.cells?.forEach(cell => {
                    ctx.fillRect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                });
                ctx.globalAlpha = 1;
            });
        }

        function drawPowerups() {
            gameState.powerups?.forEach(p => {
                ctx.fillStyle = COLORS.powerup;
                ctx.fillRect(p.gridX * CELL_SIZE + 10, p.gridY * CELL_SIZE + 10, CELL_SIZE - 20, CELL_SIZE - 20);
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                const icon = p.type === 'BOMB' ? 'üí£' : p.type === 'FLAME' ? 'üî•' : '‚ö°';
                ctx.fillText(icon, p.gridX * CELL_SIZE + CELL_SIZE / 2, p.gridY * CELL_SIZE + CELL_SIZE / 2 + 7);
            });
        }

        function drawBombs() {
            gameState.bombs?.forEach(b => {
                ctx.fillStyle = COLORS.bomb;
                ctx.beginPath();
                ctx.arc(b.gridX * CELL_SIZE + CELL_SIZE / 2, b.gridY * CELL_SIZE + CELL_SIZE / 2, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üí£', b.gridX * CELL_SIZE + CELL_SIZE / 2, b.gridY * CELL_SIZE + CELL_SIZE / 2 + 5);
            });
        }

        function drawPlayers() {
            gameState.players?.forEach(p => {
                if (p.lives > 0) {
                    ctx.fillStyle = COLORS.player[p.colorIndex || 0];
                    ctx.fillRect(p.gridX * CELL_SIZE + 8, p.gridY * CELL_SIZE + 8, CELL_SIZE - 16, CELL_SIZE - 16);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(p.nickname?.substring(0, 3) || 'P', p.gridX * CELL_SIZE + CELL_SIZE / 2, p.gridY * CELL_SIZE + CELL_SIZE / 2 + 4);
                }
            });
        }

        function render() {
            drawGrid();
            drawExplosions();
            drawPowerups();
            drawBombs();
            drawPlayers();
            requestAnimationFrame(render);
        }

        function connectWebSocket() {
            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                addLog('WebSocket connected', 'success');
                updateStatus('Connected', true);
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                addLog(`‚Üê ${msg.type}`, 'info');

                switch (msg.type) {
                    case 'LOBBY_JOINED':
                        addLog(`Joined lobby, waiting for players...`, 'success');
                        break;
                    case 'PLAYER_JOINED':
                        addLog(`${msg.nickname} joined (${msg.players?.length || 0} players)`, 'success');
                        break;
                    case 'COUNTDOWN_TICK':
                        updateStatus(`Starting in ${msg.remaining}s...`, true);
                        break;
                    case 'GAME_STARTED':
                        myPlayerId = msg.yourPlayerId;
                        gameState.players = msg.players || [];
                        gameState.bombs = [];
                        gameState.explosions = [];
                        gameState.powerups = [];
                        gameState.mapData = msg.mapData;
                        addLog(`Game started! You are ${myPlayerId}`, 'success');
                        updateStatus('In Game', true);
                        updatePlayersList();
                        updateInfo();
                        break;
                    case 'FULL_STATE':
                        gameState = msg;
                        updatePlayersList();
                        updateInfo();
                        break;
                    case 'PLAYER_MOVED':
                        const player = gameState.players.find(p => p.playerId === msg.playerId);
                        if (player) {
                            player.gridX = msg.gridX;
                            player.gridY = msg.gridY;
                            if (msg.playerId === myPlayerId) updateInfo();
                        }
                        break;
                    case 'BOMB_PLACED':
                        gameState.bombs.push(msg);
                        addLog(`Bomb placed at (${msg.gridX}, ${msg.gridY})`, 'info');
                        break;
                    case 'BOMB_EXPLODED':
                        gameState.bombs = gameState.bombs.filter(b => b.id !== msg.bombId);
                        gameState.explosions.push(msg);
                        setTimeout(() => {
                            gameState.explosions = gameState.explosions.filter(e => e.bombId !== msg.bombId);
                        }, 500);
                        addLog(`Bomb exploded!`, 'success');
                        break;
                    case 'BLOCKS_DESTROYED':
                        if (gameState.mapData?.initial_grid) {
                            msg.blocks?.forEach(b => {
                                if (gameState.mapData.initial_grid[b.y]) {
                                    gameState.mapData.initial_grid[b.y][b.x] = 0;
                                }
                            });
                        }
                        break;
                    case 'POWERUP_SPAWNED':
                        gameState.powerups.push(msg);
                        break;
                    case 'POWERUP_COLLECTED':
                        gameState.powerups = gameState.powerups.filter(p => p.id !== msg.powerupId);
                        const p = gameState.players.find(pl => pl.playerId === msg.playerId);
                        if (p) {
                            if (msg.powerupType === 'BOMB') p.maxBombs = (p.maxBombs || 1) + 1;
                            if (msg.powerupType === 'FLAME') p.flameRange = (p.flameRange || 1) + 1;
                            if (msg.powerupType === 'SPEED') p.speed = (p.speed || 1) + 0.5;
                        }
                        addLog(`${msg.playerId} collected ${msg.powerupType}`, 'success');
                        updatePlayersList();
                        updateInfo();
                        break;
                    case 'PLAYER_DAMAGED':
                        const damaged = gameState.players.find(pl => pl.playerId === msg.playerId);
                        if (damaged) damaged.lives = msg.livesRemaining;
                        addLog(`${msg.playerId} damaged! Lives: ${msg.livesRemaining}`, 'error');
                        updatePlayersList();
                        updateInfo();
                        break;
                    case 'PLAYER_DIED':
                        const died = gameState.players.find(pl => pl.playerId === msg.playerId);
                        if (died) died.lives = 0;
                        addLog(`${msg.playerId} died!`, 'error');
                        updatePlayersList();
                        break;
                    case 'GAME_OVER':
                        addLog(`GAME OVER! Winner: ${msg.winner || 'None'}`, 'success');
                        updateStatus('Game Over', false);
                        break;
                    case 'ERROR':
                        addLog(`Error: ${msg.message}`, 'error');
                        break;
                }
            };

            ws.onerror = (err) => {
                addLog('WebSocket error', 'error');
                updateStatus('Error', false);
            };

            ws.onclose = () => {
                addLog('WebSocket closed', 'error');
                updateStatus('Disconnected', false);
                setTimeout(connectWebSocket, 3000);
            };
        }

        function send(type, data = {}) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type, ...data }));
                addLog(`‚Üí ${type}`, 'info');
            }
        }

        // Event listeners
        document.getElementById('join-btn').onclick = () => {
            const nickname = document.getElementById('nickname').value || 'Player1';
            send('JOIN_GAME', { nickname });
        };

        document.getElementById('up-btn').onclick = () => send('MOVE', { direction: 'UP' });
        document.getElementById('down-btn').onclick = () => send('MOVE', { direction: 'DOWN' });
        document.getElementById('left-btn').onclick = () => send('MOVE', { direction: 'LEFT' });
        document.getElementById('right-btn').onclick = () => send('MOVE', { direction: 'RIGHT' });
        document.getElementById('bomb-btn').onclick = () => send('PLACE_BOMB');
        document.getElementById('state-btn').onclick = () => send('REQUEST_STATE');
        document.getElementById('clear-btn').onclick = () => log.innerHTML = '';

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!connected) return;
            switch (e.key.toLowerCase()) {
                case 'w': case 'arrowup': send('MOVE', { direction: 'UP' }); break;
                case 's': case 'arrowdown': send('MOVE', { direction: 'DOWN' }); break;
                case 'a': case 'arrowleft': send('MOVE', { direction: 'LEFT' }); break;
                case 'd': case 'arrowright': send('MOVE', { direction: 'RIGHT' }); break;
                case ' ': send('PLACE_BOMB'); e.preventDefault(); break;
            }
        });

        // Initialize
        connectWebSocket();
        render();
        addLog('Client initialized. Enter nickname and click Join Game', 'success');
    </script>
</body>

</html>